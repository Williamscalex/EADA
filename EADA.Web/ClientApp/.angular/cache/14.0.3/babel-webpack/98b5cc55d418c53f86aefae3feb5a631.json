{"ast":null,"code":"import _asyncToGenerator from \"E:/Program Files (x86)/repos/EADA/EADA.Web/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { filter, first, map, shareReplay, startWith, Subject, tap } from 'rxjs';\nimport { firstBy } from 'thenby';\nimport { HttpErrorCodes, isCritical, SESSION_EXPIRED_ERROR } from '@global/errors';\nimport { newId } from '@global/utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"angular-notifier\";\nimport * as i2 from \"./logger.service\";\n/**\r\n * The number of past errors stored in the errorIds array.\r\n */\n\nconst ERROR_HISTORY_COUNT = 10;\nexport class ErrorNotifierService {\n  constructor(notifier, logger) {\n    this.notifier = notifier;\n    this.logger = logger;\n    this.errorSubject = new Subject();\n    /**\r\n     * Internal object used to provided error history. This property should not be used directly as it may be\r\n     * constantly mutating as errors occur. To access this data, use the {@link errorHistory$} observable.\r\n     * Contains the recent errors that have occurred and their timestamps.\r\n     */\n\n    this._errorHistoryData = {};\n    /**\r\n     * A dictionary of the most recent errors, grouped by their {@link ErrorNotification.id IDs},\r\n     * and set to the value of the timestamp when they occurred.\r\n     */\n\n    this.errorHistory$ = this.errorSubject.pipe(map(err => err === null || err === void 0 ? void 0 : err.id), startWith(null), this.recordErrorInHistory());\n    /**\r\n     * A list of error IDs found in the current history.\r\n     */\n\n    this.errorHistoryKeys$ = this.errorHistory$.pipe(map(data => Object.keys(data)), shareReplay(1));\n    this.allErrors$ = this.errorSubject.asObservable();\n    this.criticalError$ = this.errorSubject.pipe(filter(e => this.isShowableErrorType(e)), tap(err => {\n      this.lastCriticalErrorTimestamp = Date.now();\n      this.lastCriticalError = err;\n    }));\n    this.lastCriticalErrorTimestamp = 0;\n    this.modelValidationError$ = this.errorSubject.pipe(filter(e => e.type === HttpErrorCodes.ModelValidationError));\n    this.clearErrorsSubject = new Subject();\n    this.clearErrors$ = this.clearErrorsSubject.asObservable();\n    this.logger.log('notifier service: ', notifier); // subscription should live throughout the lifetime of this instance.\n\n    this.errorHistory$.subscribe();\n  }\n\n  clearErrors() {\n    this.clearErrorsSubject.next(null);\n  }\n  /**\r\n   * Adds an error to the history data object.\r\n   * @returns An output observable that will emit the error IDs found in history after recording the error provided.\r\n   */\n\n\n  recordErrorInHistory() {\n    return source => source.pipe(tap(id => {\n      // skip if error nothing\n      if (!id) return;else if (this._errorHistoryData[id]) {\n        // if already logged, then update the timestamp\n        this._errorHistoryData[id] = Date.now();\n        return;\n      } // current IDs in error history\n\n      const currentIds = Object.keys(this._errorHistoryData); // make room for new error\n\n      if (currentIds.length >= ERROR_HISTORY_COUNT) {\n        // get error IDs, sorted from oldest to newest\n        const entries = Object.entries(this._errorHistoryData).sort(firstBy(x => x[1], 'asc'));\n\n        while (entries.length >= ERROR_HISTORY_COUNT) {\n          const oldId = entries.pop()[0];\n          delete this._errorHistoryData[oldId];\n        }\n      } // add the error to our history\n\n\n      this._errorHistoryData[id] = Date.now();\n    }), shareReplay(1), map(() => Object.assign({}, this._errorHistoryData)));\n  }\n  /**\r\n   * Determines if a critical error has been reported recently.\r\n   */\n\n\n  isReported(criticalError) {\n    const now = Date.now();\n    if (!this.lastCriticalError || now - this.lastCriticalErrorTimestamp > 5000) return false;\n    return this.lastCriticalError === criticalError;\n  }\n  /**\r\n   * Determines if the given error should be shown to the user.\r\n   */\n\n\n  isShowableErrorType(err) {\n    return !!(isCritical(err) && this.notifier && err.error !== SESSION_EXPIRED_ERROR && err.status !== 401 && err.status !== 403);\n  }\n\n  errorHistoryIncludes(id, timeSinceErrorMilliseconds = null) {\n    if (!timeSinceErrorMilliseconds) return this.errorHistoryKeys$.pipe(first(), map(ids => ids.includes(id)));\n    const errorTime = Date.now() - timeSinceErrorMilliseconds;\n    return this.errorHistory$.pipe(first(), map(data => {\n      const entry = Object.entries(data).find(([key, timestamp]) => key === id && timestamp >= errorTime);\n      return !!entry;\n    }));\n  }\n  /**\r\n   * Processes the given {@link err error} and triggers the workflow of events\r\n   * that emit and track errors in the client app. If the error was emitted recently\r\n   * (i.e., if it's ID was found in the {@link errorHistory$ history}) then the method call will be ignored.\r\n   * @param err The error that occurred.\r\n   * @param ignoreDuplicates When true or unsupplied (default), the error event will not be emitted if it has been\r\n   * recently emitted for the same error.\r\n   * @returns The error ID.\r\n   */\n\n\n  onError(err, ignoreDuplicates = true) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!err) {\n        // bad data provided\n        _this.logger.warn('The \"onError\" function was called without any error data. No error will be recorded.');\n\n        return '';\n      } // ensure ID is set\n\n\n      if (err && !err.id) err.id = newId(); // check if exists in history\n\n      const exists = yield _this.errorHistoryIncludes(err.id).toPromise();\n\n      if (ignoreDuplicates && !exists) {\n        // error not found in history, continue\n        _this.logger.warn('Error thrown! ', err);\n\n        _this.errorSubject.next(err);\n\n        if (_this.isShowableErrorType(err)) {\n          if (err.type !== 0) {\n            _this.notifier.notify('error', err.error);\n          } else {\n            _this.notifier.notify('error', 'An unexpected error occured.');\n          }\n        }\n      } else {\n        // error found in history; omit call\n        _this.logger.warn(`An error was thrown that had already been recorded recently. Error ID: ${err.id}`);\n      }\n\n      return err.id;\n    })();\n  }\n\n  showWarning(message) {\n    this.notifier.notify('warning', message);\n  }\n\n  showError(message) {\n    var _a;\n\n    if (message instanceof Error) message = (_a = message === null || message === void 0 ? void 0 : message.message) !== null && _a !== void 0 ? _a : 'An unexpected client-side error occurred.';\n    this.notifier.notify('error', message);\n  }\n\n}\n\nErrorNotifierService.ɵfac = function ErrorNotifierService_Factory(t) {\n  return new (t || ErrorNotifierService)(i0.ɵɵinject(i1.NotifierService, 8), i0.ɵɵinject(i2.LoggerService));\n};\n\nErrorNotifierService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: ErrorNotifierService,\n  factory: ErrorNotifierService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["filter","first","map","shareReplay","startWith","Subject","tap","firstBy","HttpErrorCodes","isCritical","SESSION_EXPIRED_ERROR","newId","ERROR_HISTORY_COUNT","ErrorNotifierService","constructor","notifier","logger","errorSubject","pipe","err","id","recordErrorInHistory","errorHistory$","data","Object","keys","asObservable","e","isShowableErrorType","lastCriticalErrorTimestamp","Date","now","lastCriticalError","type","ModelValidationError","clearErrorsSubject","log","subscribe","clearErrors","next","source","_errorHistoryData","currentIds","length","entries","sort","x","oldId","pop","isReported","criticalError","error","status","errorHistoryIncludes","timeSinceErrorMilliseconds","errorHistoryKeys$","ids","includes","errorTime","entry","find","key","timestamp","onError","ignoreDuplicates","warn","exists","toPromise","notify","showWarning","message","showError","Error","_a","i0","factory","providedIn"],"sourceRoot":"","sources":["E:\\Program Files (x86)\\repos\\EADA\\EADA.Web\\ClientApp\\src\\app\\services\\error-notifier.service.ts"],"sourcesContent":["import { Injectable, Optional, Inject } from '@angular/core';\r\nimport { NotifierService } from 'angular-notifier';\r\nimport { BehaviorSubject, filter, first, map, Observable, ReplaySubject, shareReplay, startWith, Subject, tap } from 'rxjs';\r\nimport { LoggerService } from './logger.service';\r\nimport { firstBy } from 'thenby';\r\nimport { ErrorNotification, HttpErrorCodes, isCritical, SESSION_EXPIRED_ERROR } from '@global/errors';\r\nimport { newId } from '@global/utils';\r\n/**\r\n * The number of past errors stored in the errorIds array.\r\n */\r\nconst ERROR_HISTORY_COUNT = 10;\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\nexport class ErrorNotifierService {\r\n  constructor(\r\n    @Optional() private notifier: NotifierService,\r\n    private logger: LoggerService\r\n  ) {\r\n    this.logger.log('notifier service: ', notifier);\r\n    // subscription should live throughout the lifetime of this instance.\r\n    this.errorHistory$.subscribe();\r\n  }\r\n  private errorSubject = new Subject<ErrorNotification>();\r\n  /**\r\n   * Internal object used to provided error history. This property should not be used directly as it may be\r\n   * constantly mutating as errors occur. To access this data, use the {@link errorHistory$} observable.\r\n   * Contains the recent errors that have occurred and their timestamps.\r\n   */\r\n  private _errorHistoryData: { [id: string]: number } = {};\r\n  /**\r\n   * A dictionary of the most recent errors, grouped by their {@link ErrorNotification.id IDs},\r\n   * and set to the value of the timestamp when they occurred.\r\n   */\r\n  public errorHistory$ = this.errorSubject.pipe(\r\n    map(err => err?.id),\r\n    startWith(null),\r\n    this.recordErrorInHistory());\r\n  /**\r\n   * A list of error IDs found in the current history.\r\n   */\r\n  public errorHistoryKeys$ = this.errorHistory$.pipe(\r\n    map(data => Object.keys(data)),\r\n    shareReplay(1)\r\n  );\r\n  public allErrors$ = this.errorSubject.asObservable();\r\n  public criticalError$ = this.errorSubject.pipe(\r\n    filter((e) => this.isShowableErrorType(e)),\r\n    tap((err) => {\r\n      this.lastCriticalErrorTimestamp = Date.now();\r\n      this.lastCriticalError = err;\r\n    })\r\n  );\r\n  private lastCriticalErrorTimestamp: number = 0;\r\n  private lastCriticalError: ErrorNotification;\r\n  public modelValidationError$ = this.errorSubject.pipe(\r\n    filter((e) => e.type === HttpErrorCodes.ModelValidationError)\r\n  );\r\n  private clearErrorsSubject = new Subject();\r\n  public clearErrors$ = this.clearErrorsSubject.asObservable();\r\n  public clearErrors() {\r\n    this.clearErrorsSubject.next(null);\r\n  }\r\n  /**\r\n   * Adds an error to the history data object.\r\n   * @returns An output observable that will emit the error IDs found in history after recording the error provided.\r\n   */\r\n  private recordErrorInHistory(): (\r\n    source: Observable<string>  ) => Observable<{[id:string]:number}> {\r\n    return (source) => source.pipe(\r\n      tap(id => {\r\n        // skip if error nothing\r\n        if(!id) return;\r\n        else if(this._errorHistoryData[id]) {\r\n          // if already logged, then update the timestamp\r\n          this._errorHistoryData[id] = Date.now();\r\n          return;\r\n        }\r\n        // current IDs in error history\r\n        const currentIds = Object.keys(this._errorHistoryData);\r\n        // make room for new error\r\n        if (currentIds.length >= ERROR_HISTORY_COUNT) {\r\n          // get error IDs, sorted from oldest to newest\r\n          const entries = Object\r\n          .entries(this._errorHistoryData)\r\n          .sort(firstBy(x => x[1], 'asc'));\r\n          while (entries.length >= ERROR_HISTORY_COUNT) {\r\n            const oldId = entries.pop()[0];\r\n            delete this._errorHistoryData[oldId];\r\n          }\r\n        }\r\n        // add the error to our history\r\n        this._errorHistoryData[id] = Date.now();\r\n      }),\r\n      shareReplay(1),\r\n      map(() => ({...this._errorHistoryData}))\r\n    )\r\n  }\r\n  /**\r\n   * Determines if a critical error has been reported recently.\r\n   */\r\n  isReported(criticalError: ErrorNotification) {\r\n    const now = Date.now();\r\n    if (!this.lastCriticalError || now - this.lastCriticalErrorTimestamp > 5000)\r\n      return false;\r\n    return this.lastCriticalError === criticalError;\r\n  }\r\n  /**\r\n   * Determines if the given error should be shown to the user.\r\n   */\r\n  private isShowableErrorType(err: ErrorNotification): boolean {\r\n    return !!(\r\n      isCritical(err) &&      this.notifier &&      err.error !== SESSION_EXPIRED_ERROR &&      err.status !== 401 &&      err.status !== 403\r\n    );\r\n  }\r\n  /**\r\n   * Checks if the given error ID exists in the current error history data.\r\n   * @param id The error ID to check for.\r\n   * @returns A cold observable emitting the result of the check.\r\n   */\r\n  public errorHistoryIncludes(id:string):Observable<boolean>  /**\r\n   * Checks if the given error ID exists in the error history and has occurred within the last {@link timeSinceErrorMilliseconds X milliseconds}.\r\n   * @param id The error ID to check for.\r\n   * @param timeSinceErrorMilliseconds Time since the error occurred, in milliseconds.\r\n   * @returns A cold observable emitting the result of the check.\r\n   */\r\n  public errorHistoryIncludes(id:string, timeSinceErrorMilliseconds:number):Observable<boolean>  \r\n  public errorHistoryIncludes(id:string, timeSinceErrorMilliseconds:number = null):Observable<boolean> {\r\n    if(!timeSinceErrorMilliseconds) return this.errorHistoryKeys$.pipe(\r\n      first(),\r\n      map(ids => ids.includes(id)));\r\n      const errorTime = Date.now() - timeSinceErrorMilliseconds;\r\n      return this.errorHistory$.pipe(\r\n        first(),\r\n        map(data => {\r\n          const entry = Object.entries(data).find(([key,timestamp]) => key === id && timestamp >= errorTime);\r\n          return !!entry;\r\n        })\r\n      );\r\n  }\r\n  /**\r\n   * Processes the given {@link err error} and triggers the workflow of events\r\n   * that emit and track errors in the client app. If the error was emitted recently\r\n   * (i.e., if it's ID was found in the {@link errorHistory$ history}) then the method call will be ignored.\r\n   * @param err The error that occurred.\r\n   * @param ignoreDuplicates When true or unsupplied (default), the error event will not be emitted if it has been\r\n   * recently emitted for the same error.\r\n   * @returns The error ID.\r\n   */\r\n  public async onError(err: ErrorNotification, ignoreDuplicates:boolean = true): Promise<string> {\r\n    if(!err) { // bad data provided\r\n      this.logger.warn('The \"onError\" function was called without any error data. No error will be recorded.');\r\n      return '';\r\n    }\r\n    // ensure ID is set\r\n    if (err && !err.id) err.id = newId();\r\n    // check if exists in history\r\n    const exists = await this.errorHistoryIncludes(err.id).toPromise();\r\n    if(ignoreDuplicates && !exists) { // error not found in history, continue\r\n      this.logger.warn('Error thrown! ', err);\r\n      this.errorSubject.next(err);\r\n      if (this.isShowableErrorType(err)) {\r\n        if (err.type !== 0) {\r\n          this.notifier.notify('error', err.error as string);\r\n        } else {\r\n          this.notifier.notify('error', 'An unexpected error occured.');\r\n        }\r\n      }\r\n    } else {\r\n      // error found in history; omit call\r\n      this.logger.warn(`An error was thrown that had already been recorded recently. Error ID: ${err.id}`);\r\n    }\r\n    return err.id;\r\n  }\r\n  public showWarning(message: string): void {\r\n    this.notifier.notify('warning', message);\r\n  }\r\n  public showError(message: string | Error): void {\r\n    if (message instanceof Error)\r\n      message = message?.message ?? 'An unexpected client-side error occurred.';\r\n    this.notifier.notify('error', message);\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}